# HTTP Cache

---

> HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求。

可复用性有几个优点:

- 首先，由于不需要将请求传递到源服务器，因此客户端和缓存越近，响应速度就越快。最典型的例子是浏览器本身为浏览器请求存储缓存。
- 减轻服务器负载

## 不同种类的缓存

- 私有缓存

  > 私有缓存是绑定到特定客户端的缓存——通常是浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。

如果响应包含个性化内容并且你只想将响应存储在私有缓存中，则必须指定 private 指令。

```
Cache-Control: private
```

请注意，如果响应具有 Authorization 标头，则不能将其存储在私有缓存（或共享缓存，除非 Cache-Control 指定的是 public）中。

- 共享缓存

  > 共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为代理缓存和托管缓存。

      - 代理缓存
        > 除了访问控制的功能外，一些代理还实现了缓存以减少网络流量

      - 托管缓存
        > 托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。示例包括反向代理、CDN 和 service worker 与缓存 API 的组合。

## 启发式缓存

> 没有给出 Cache-Control，如果满足某些条件，响应也会被存储和重用

## 基于 age 的缓存策略

> 存储的 HTTP 响应有两种状态：fresh 和 stale。fresh 状态通常表示响应仍然有效，可以重复使用，而 stale 状态表示缓存的响应已经过期。

```
Cache-Control: max-age=604800
```

如果存储在共享缓存中，那么响应还会添加`Age`标头

## Expires 或 max-age

> http1.0: Expires 标头使用明确的时间而不是通过指定经过的时间来指定缓存的生命周期。
> htt1.1: max-age，两个都存在则 max-age 为首选

## Vary 响应

> 区分响应的方式本质上是基于它们的 URL

- 例如，对于带有 Accept-Language: en 标头并已缓存的英语内容，不希望再对具有 Accept-Language: ja 请求标头的请求重用该缓存响应。在这种情况下，你可以通过在 Vary 标头的值中添加“Accept-Language”，根据语言单独缓存响应。

```
Vary: Accept-Language
```

- 对于`User-Agent`不建议

  - 因为种类太多，降低了缓存的重复利用机会，推荐一种基于特征检测的方法

- 对于使用 cookie 来防止其他人重复使用缓存的个性化内容，应该使用私有缓存，而不是设置 Vary: cookie

## 验证响应

> 过时的响应不会立即被丢弃。HTTP 有一种机制，可以通过询问源服务器将陈旧的响应转换为新的响应。这称为验证，有时也称为重新验证。

> 验证是通过使用包含 If-Modified-Since 或 If-None-Match 请求标头的条件请求完成的。

- `If-Modified-Since`

如果内容自指定时间以来没有更改，服务器将响应 304 Not Modified。

- `ETag/If-None-Match`

ETag 响应标头的值是服务器生成的任意值。服务器对于生成值没有任何限制，因此服务器可以根据他们选择的任何方式自由设置值——例如主体内容的哈希或版本号。

如果该响应是陈旧的，则客户端获取缓存响应的 ETag 响应标头的值，并将其放入 If-None-Match 请求标头中，以询问服务器资源是否已被修改：匹配则返回 304 Not Modified

> 注意：ETag 与 Last-Modified 同时存在时 ETag 优先

## 强制重新验证

> 希望始终从服务器获取最新的内容，可以设置`no-cache`指令强制验证

通过在响应中添加 Cache-Control: no-cache 以及 Last-Modified 和 ETag——如下所示——如果请求的资源已更新，客户端将收到 200 OK 响应，否则，如果请求的资源尚未更新，则会收到 304 Not Modified 响应。

上面的意思是每次请求都要强制验证当前资源是否已经更新，因为在前面提到的只会在存储的响应变为 stage 的时候才会去验证，即强制验证是不管存储的缓存处在 flush 与 stage 状态都会进行验证

> max-age=0 和 must-revalidate 的组合与 no-cache 具有相同的含义。

## 不使用缓存

> no-cache/注意上一节提到, 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。

> 如果你不希望将响应存储在任何缓存中，请使用 no-store。

```
Cache-Control: no-store
```

不使用缓存的原因:

- 出于隐私原因，不希望特定客户以外的任何人存储响应。
- 希望始终提供最新信息。
- 不知道在过时的实现中会发生什么。

> 在这种情况下，no-store 并不总是最合适的指令。

- `no-store, private`: 特定用户不共享
- `no-cache`: 总是最新，总是进行验证
- `no-cache`: 有很多妙用，仔细体会吧

> 因此，要获得 Web 平台的全部功能集的优势，最好将 no-cache 与 private 结合使用。

## 请求折叠

> 当多个相同请求同时到达共享缓存，中间缓存将代表自己将单个请求转发到源，将结果重用于所有的客户端

## 常见的缓存模式

### 通用

- 默认设置: 启发式缓存
- 请求最新数据，做法是修改默认为`no-cache`
- 实现了 Cookie 登录，并且内容为每个用户个性化，必须添加`private`

> 只有在设置了 Authorization 标头时需要存储响应时才应使用 public 指令。否则不需要，因为只要给出了 max-age，响应就会存储在共享缓存中。

### 缓存破坏:子资源 URL 变化，例如 hash 值`path.hash`

> 对于无法通过破坏缓存例如主要资源，可以利用托管缓存，例如 CDN
