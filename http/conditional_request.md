# HTTP 条件请求

---

- 缓存
- 验证

> 在 HTTP 协议中有一个“条件式请求”的概念，在这类请求中，请求的结果，甚至请求成功的状态，都会随着验证器与受影响资源的比较结果的变化而变化。这类请求可以用来验证缓存的有效性，省去不必要的控制手段，以及验证文件的完整性，例如在断点续传的场景下或者在上传或者修改服务器端的文件的时候避免更新丢失问题。

## 条件首部

一些被称为条件首部的 HTTP 首部，可以引发条件请求。它们是:

- `If-Match`
  如果远端资源的实体标签与在 ETag 这个首部中列出的值相同的话，表示条件匹配成功。默认地，除非实体标签带有 'W/' 前缀，否者它将会执行强验证。

- `If-None-Match`
  如果远端资源的实体标签与在 ETag 这个首部中列出的值都不相同的话，表示条件匹配成功。默认地，除非实体标签带有 'W/' 前缀，否者它将会执行强验证。

- `If-Modified-Since`
  如果远端资源的 Last-Modified 首部标识的日期比在该首部中列出的值要更晚，表示条件匹配成功。

- `If-Unmodified-Since`
  如果远端资源的 HTTPHeader("Last-Modified")}} 首部标识的日期比在该首部中列出的值要更早或相同，表示条件匹配成功。

- `If-Range`
  与 If-Match 或 If-Unmodified-Since 相似，但是只能含有一个实体标签或者日期值。如果匹配失败，则条件请求宣告失败，此时将不会返回 206 Partial Content 响应码，而是返回 200 OK 响应码，以及完整的资源。

## 应用场景

- 缓存更新

- 增量下载的完整性
  支持增量下载的服务器会通过 Accept-Ranges 首部来广播这项能力。此后客户端就可以通过发送 Ranges (en-US) 首部字段以及缺失的范围值来进行断点续传了：

- 使用乐观锁避免更新丢失问题
  > 常见是远程更新文件，例如版本控制、CMS。
  > 需要使用`If-Match`与`If-Unmodified-Since`首部。如果条件没有满足则返回 412 Precondition Failed 状态码


## 处理资源的首次上传
> 由于多用户原因，在上传时存在竞态条件，为了防止这种情况发生，可以使用条件式请求: 添加`If-None-Match`首部，并将其值设置为`*`，
表示匹配任意实体标签，当且仅当资源不存在的情况下请求才会成功执行，并返回201 Created状态码
